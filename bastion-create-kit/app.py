from flask import Flask, render_template, request, flash, redirect, url_for
import subprocess as sp
import os, time, random

app = Flask(__name__)
# flash 메시지 기능을 사용하기 위한 시크릿 키
app.config['SECRET_KEY'] = 'a-very-secret-key-that-should-be-changed'

# Kickstart 템플릿
KS_TEMPLATE = """
# Kickstart file for RHEL 9.6 Bastion VM - Generated by WebUI
lang ko_KR.UTF-8
keyboard --xlayouts='kr'
timezone Asia/Seoul --utc
rootpw --plaintext ##ROOT_PASSWORD##


# BaseOS와 AppStream 리포지토리를 명시적으로 지정
url --url="http://##HOST_IP##:8080/rhel9.6/BaseOS"
repo --name="AppStream" --baseurl="http://##HOST_IP##:8080/rhel9.6/AppStream"
network --bootproto=static --device=ens3 --ip=##BASTION_IP## --netmask=255.255.255.0 --gateway=10.0.1.1 --nameserver=8.8.8.8 --hostname=##HOSTNAME## --activate

# --- 핵심 파티션 설정 (수동 방식) ---
# 1. 디스크의 모든 파티션을 깨끗하게 지웁니다.
clearpart --all --initlabel
# 2. 부팅에 필요한 /boot 파티션을 1GB로 생성합니다.
part /boot --fstype="xfs" --size=1024
# 3. 나머지 모든 공간을 차지하는 LVM 물리 볼륨을 생성합니다.
#    --size=1 --grow 옵션이 남은 공간 전체를 사용하라는 의미입니다.
part pv.01 --size=1 --grow
# 4. 'rootvg' 라는 이름으로 볼륨 그룹을 생성합니다.
volgroup rootvg pv.01
# 5. swap 공간을 4GB로 생성합니다. (필요에 따라 크기 조절)
logvol swap --vgname=rootvg --name=lv_swap --size=4096
# 6. 남은 모든 공간을 루트(/) 파티션으로 할당합니다.
#    --size=1 --grow 옵션을 사용해 남은 공간 전체를 할당합니다.
logvol / --vgname=rootvg --name=lv_root --fstype="xfs" --size=1 --grow


# --- 핵심 파티션 설정 ---
# 1. 디스크의 모든 파티션을 깨끗하게 지웁니다.
#clearpart --all --initlabel

# 2. 자동으로 파티션을 설정합니다.
#    - /boot 파티션과 swap 파티션은 자동으로 생성됩니다.
#    - --nohome 옵션으로 /home 파티션을 만들지 않고,
#      남은 모든 공간을 루트(/) 파티션에 할당합니다.
#autopart --nohome




services --enabled="chronyd,httpd,named,sshd"
selinux --disabled
firewall --disabled
bootloader --location=mbr --boot-drive=vda
graphical
skipx

%packages
@^minimal-environment
haproxy
bind
bind-utils
chrony
httpd
httpd-tools
python3
python3-pip
ansible-core
nmstate
wget
podman
skopeo
jq
tar
gcc
python3-devel
rsync
policycoreutils-python-utils
openssh-server
vim
bash-completion
%end


%post --log=/root/ks-post.log
cat >/etc/ssh/sshd_config.d/10-root-login.conf <<'EOF'
PermitRootLogin yes
PasswordAuthentication yes
EOF
systemctl enable sshd
pip3 install Flask Flask-WTF


%end

reboot

"""

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        action = request.form.get('action')
        try:
            if action == 'generate_kickstart':
                ks_content = KS_TEMPLATE.replace("##ROOT_PASSWORD##", request.form.get('root_password')) \
                                        .replace("##HOSTNAME##", request.form.get('hostname')) \
                                        .replace("##BASTION_IP##", request.form.get('bastion_ip')) \
                                        .replace("##HOST_IP##", request.form.get('host_ip'))

                ks_path = "/var/www/html/kickstart/ks.cfg"
                with open(ks_path, "w") as f:
                    f.write(ks_content)
                
                #sp.run(['sudo', 'restorecon', '-v', ks_path], check=True)
                flash(f"✅ Kickstart 파일이 {ks_path} 에 성공적으로 생성되었습니다.", 'success')

            elif action == 'download_iso':
                # 사용자가 입력한 URL을 가져옵니다
                iso_url = request.form.get('iso_url_from_user')
                if not iso_url or not iso_url.startswith('http'):
                    flash("❌ 오류: 유효한 다운로드 URL을 입력해야 합니다.", 'danger')
                    return redirect(url_for('index'))

                # 다운로드될 파일 이름 지정 (URL이 복잡하므로 고정된 이름 사용)
                iso_filename = "rhel-9.6-x86_64-dvd.iso"
                download_path = f"/tmp/{iso_filename}"
                mount_path = "/var/www/html/rhel9.6"

                flash(f"ISO 다운로드를 시작합니다... (대상: {mount_path})", 'info')
               
                # wget과 mount 실행
                sp.run(['sudo', 'wget', '-O', download_path, iso_url], check=True)
                sp.run(['sudo', 'mount', '-o', 'loop', download_path, mount_path], check=True)
                
                flash(f"✅ ISO 이미지를 성공적으로 다운로드하고 {mount_path} 에 마운트했습니다.", 'success')

                # [수정] 마운트된 디렉터리에 올바른 SELinux 컨텍스트를 재귀적으로 적용
                #sp.run(['sudo', 'restorecon', '-Rv', mount_path], check=True)

                flash(f"✅ ISO 이미지를 성공적으로 마운트했습니다 ({mount_path}).", 'success')



            elif action == 'create_vm':
                # vCPUs, RAM, Disk Size 값 읽어오기
                vm_name = request.form.get('vm_name')
                vcpus = request.form.get('vm_vcpus', '4')
                ram_gb = int(request.form.get('vm_ram', '16'))
                disk_size = request.form.get('disk_size', '300')

                # RAM을 GB에서 MB로 변환
                ram_mb = ram_gb * 1024
                
                location_url = f"http://10.0.1.103:8080/rhel9.6/"
                ks_location = f"http://10.0.1.103:8080/kickstart/ks.cfg"

                disk_dir = "/KVM_data/vm"
                os.makedirs(disk_dir, exist_ok=True)
                disk_path = f"{disk_dir}/{vm_name}.qcow2"
                if os.path.exists(disk_path):
                    flash(f"❌ 디스크가 이미 존재합니다: {disk_path}", 'danger')
                    return redirect(url_for('index'))

                def gen_mac():
                    return "52:54:00:%02x:%02x:%02x" % tuple(random.randint(0,255) for _ in range(3))

                MAC = gen_mac()
                iface = 'ens3'
                vm_ip = request.form.get('vm_ip')
                gw = '10.0.1.1'
                mask = '255.255.255.0'


                extra = (
                        f"rd.neednet=1 rd.net.timeout.carrier=60 "
                        f"inst.stage2={location_url} inst.repo={location_url} inst.ks={ks_location} "
                        f"ifname={iface}:{MAC} "
                        f"ip={vm_ip}::{gw}:{mask}::{iface}:none "
                        f"inst.ks.device={iface} nameserver=8.8.8.8"
                )

                # virt-install 명령어에 동적 값 적용
                virt_install_cmd = [
                    'sudo', 'virt-install',
                    '--name', vm_name,
                    '--memory', str(ram_mb),
                    '--vcpus', vcpus,
                    '--disk', f'path={disk_path},size={disk_size},format=qcow2,bus=virtio',
                    '--network', f'bridge=kvmbr0,model=virtio,mac={MAC}',
                    '--graphics', 'vnc,listen=0.0.0.0',
                    '--location', location_url,
                    '--extra-args', extra,
                    '--noautoconsole'
                ]






                result = sp.run(virt_install_cmd, stdout=sp.PIPE, stderr=sp.PIPE, text=True, check=True)
                flash("🚀 VM 생성 명령을 실행했습니다. `virt-manager` 또는 `virsh list`로 상태를 확인하세요.", 'success')

        except sp.CalledProcessError as e:
            err = e.stderr if e.stderr else str(e)
            flash(f"❌ 명령어 실행 오류: {e.stderr}", 'danger')
        except TypeError as e:
            try:
                result = sp.run(virt_install_cmd, stdout=sp.PIPE, stderr=sp.PIPE, universal_newlines=True, check=True)
                flash("🚀 VM 생성 명령을 실행했습니다. `virt-manager` 또는 `virsh list`로 상태를 확인하세요.", 'success')
            except sp.CalledProcessError as ee:
                err = ee.stderr if ee.stderr else str(ee)
                flash(f"❌ 명령어 실행 오류: {err}", 'danger')
        except Exception as e:
            flash(f"❌ 일반 오류 발생: {e}", 'danger')

        return redirect(url_for('index'))

    return render_template('index.html')

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5011, debug=True)
